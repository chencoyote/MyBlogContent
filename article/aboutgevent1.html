Title: 线程和微线程(协程)
Date: 2015-1-28 16:01:23
Category: 学习笔记
Tags: python, gevent


## 背景

最近在折腾同步和异步编程的玩意, 然后就看到了gevent的异步协程库, 通过学习gevent, 也读了一些比较好的文章,基本了解了协程的内容
- [gevent程序员指南 | Gevent社区编写](http://xlambda.com/gevent-tutorial/#)
- [一起读 Gevent 源码 | fantix @ segmentfault.com](http://segmentfault.com/blog/fantix/1190000000613814)
- [gevent 学习笔记系列 | young_ipython @ segmentfault.com](http://segmentfault.com/blog/young_ipython/1190000000626309)

如果是项目的话这里有个Awesome
- [Project on wiki | gevent @ github.com](https://github.com/gevent/gevent/wiki/Projects)

当然还有官方文档
- [Docs | gevent.org](http://www.gevent.org/contents.html)

## 正文

当然前提是看过之前的文章之后的思考啦, 所以建议先阅读上面的连接

理解之后再继续

线程的并发是真正的并发

```
import threading

start = time.time()
def showtime():
    t = time.time() - start
    time.sleep(1)
    print "i work on %.3fs" % t
    return 1
for _ in range(20):
    t = threading.Thread(target=showtime)
    t.start()
```

简单的例子, 使用线程记录程序启动时间, 和开始启动线程的时间, 在`showtime()`里面print线程启动时间

```
$ python test.py
i work on 0.000s
i work on 0.000s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.002s
i work on 0.002s
i work on 0.000s
i work on 0.001s
i work on 0.002s
i work on 0.001s
i work on 0.000s
i work on 0.000s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.002s
i work on 0.002s
i work on 0.002s
```

可以看到结果几乎是同时启动的, 接下来使用gevent中的ThreadPool

```
import time
import gevent
from gevent.threadpool import ThreadPool

pool = ThreadPool(20)
start = time.time()
def showtime(n):
    t = time.time() - start
    time.sleep(2)
    print "i work on %.3fs" % t
    return 1
for _ in range(20):
    a = pool.spawn(showtime, 1)
gevent.wait()
```

创建的线程池大小是`20`, 循环执行20个任务, 最后使用gevent.wait()来等待线程的结束

```
$ python test.py
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
i work on 0.001s
```

效果相同, 但是我多次运行会出现

```
Unhandled exception in thread started by 
sys.excepthook is missing
lost sys.stderr
```
> 丢失了stderr ?? 这个是啥意思? 不知道..暂且理解为不稳定的表现, 不影响结果的执行, 也有可能是我使用的不对?

在来对比一下运行时间

```
# 20
$ python gevet_thread.py
real    0m2.026s
user    0m0.016s
sys     0m0.005s

$ python threading_thread.py
real    0m2.031s
user    0m0.020s
sys     0m0.005s
```

几乎时间是不相上下的, 接下来我们看内存

```

```